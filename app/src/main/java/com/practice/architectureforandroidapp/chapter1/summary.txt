1. 어플리케이션 설계란?
구성요소들의 유기적 관계를 표현하고, 요구 사항을 해결하려는 계획 과정 등의 원칙을 나타낸다.
텍스트, 그림, 다이어그램 등 다양한 형식을 취한다.

어플리케이션은 한 번 구현되고 나면 변경 발생 시 비용이 많이 든다.
그러므로 유지 보수에 용이한 설계를 해야 한다.

2. 어플리케이션의 설계 원칙
SOLID

SRP (단일 책임의 원칙)
클래스는 하나의 책임만 가지고 있어야 한다는 원칙.
가지고 있는 책임을 캡슐화해야 하며, 클래스에 국한되지 않고 메소드나 모듈에도 해당되는 얘기이다.
여러 클래스들이 각자 여러 개의 책임을 가지고 있게 되면, 특정 기능의 오류 발생 시 여러 클래스를 모두 수정해야 하여
수정이 힘들고 확장이나 기능 추가도 어렵게 된다.

OCP (개방 폐쇄의 원칙)
클래스는 확장에 열려있고 수정에는 닫혀 있어야 한다는 원칙.
특정 클래스를 수정함으로 인해 연관된 다른 요소들도 수정이 되지 않아야 유지보수가 용이하다.
적절한 책임 분배로 수정 범위를 최소화 할 수 있어야 하며,
또한 기능 확장이 용이하도록 잘 설계하여 기능 추가나 수정이 쉬워야 한다.

LSP (리스코프 치환 원칙)
상위 클래스를 하위 클래스로 치환하더라도 그 기능이 제대로 동작해야 한다는 원칙.
상속하더라도 상위 클래스의 본래 기능을 유지하고 만족할 수 있어야 한다.

ISP (인터페이스 분리 원칙)
어떠한 클래스가 자신이 사용하지 않는 메소드에 의존하지 않아야 한다는 원칙.
상속/구현으로 인해 사용하지 않는 메소드가 생긴다면, 해당 기능은 인터페이스로 분리해야 한다.
클래스들의 의존성이 약해지므로 유지보수 및 수정이 용이해진다.

DIP (의존성 역전 원칙)
상위 클래스가 하위 클래스에 의존하는 전통적인 관계를 역전하여 상위 클래스가 하위 클래스의 구현으로부터 분리될 수 있어야 한다는 원칙.
상위/하위 모듈은 모두 추상화에 의존해야 하고, 추상화는 세부 사항에 의존하지 않고 세부 사항이 추상화에 의존하도록 설계해햐 한다.

3. 클린 아키텍쳐
소프트웨어의 관심사를 계층별로 분리하는 소프트웨어 디자인 철학
코드 종속성이 외부로부터 내부로 의존한다
-> 내부 계층의 코드는 외부 계층의 기능을 알 수 없다.
-> 외부 계층에 존재하는 변수, 함수 및 클래스(모든 엔터티)는 안쪽 계층에서 다시 등장할 수 없다.
안쪽 계층으로 진입할수록 추상화와 캡슐화 수준이 높아진다.

Entities - Use Cases - Presenters - UI
Enterprise Business Rules - Application Business Rules - Interface Adapters - Frameworks & Drivers

장점
계층을 분리하고 계층 간의 의존성을 단방향으로 만들기 때문에
1. 코드의 재사용성이 용이해진다
2. 유닛 테스트가 쉬워진다.

Entities
전사적 비즈니스 규칙을 캡슐화한다.
데이터의 구조나 메서드를 포함하는 객체
다른 어플리케이션 사이에서 사용될 수 있다.

e.g. POJO와 같은 데이터 클래스

Use Cases
애플리케이션과 관련된 비즈니스 규칙을 포함하고 시스템의 모든 유스케이스 구현체들을 캡슐화한다.
유스케이스들은 엔터티로부터의 데이터 흐름을 관리하고,
유스케이스의 목적을 달성하도록 엔터티에 넓고 전사적인 비즈니스 규칙의 사용을 가르친다.

e.g. 안드로이드의 Model, Repository, Executor
Model : 데이터베이스의 질의나 네트워크 요청 등의 비즈니스 로직을 수행한다.
Repository : 내부 DB에 접근하거나 저장 또는 원격 서버의 데이터를 요청하는 역할을 한다.
 일반적으로 인터페이스이며 이를 구현하여 외부 계층의 연결을 느슨하게 한다.
Executor : Repository나 Model과 관련된 작업이 백그라운드에서 작업을 수행할 수 있도록 작업 스레드를 관리하고 제공한다.

Interface Adapters
유스케이스나 엔터티로부터 얻은 데이터를 가공하는 계층이다.
비즈니스 로직을 수행하여 원하는 결과 값을 얻어 UI에 표현하려고 적당한 형식으로 데이터를 변경한다.

e.g. Presenter, View, ViewModel, Controller

UI로부터 얻은 데이터를 내부 DB나 원격 서버에 전송할 때도 이 계층에서 데이터를 가공하여 전달한다.


Frameworks와 Drivers
가장 바깥쪽 계층
e.g. 안드로이드의 UI (액티비티, 프래그먼트, 인텐트 전달), 데이터베이스, 컨텐츠 프로바이더, Retrofit과 같은 네트워크 관련 프레임워크 코드


4. 안드로이드의 특징
하나의 진입점, 하나의 프로세스에서 실행되는 일반적인 어플리케이션과는 달리,
여러 프로세스로 실행될 수도 있고, 진입점도 다양하다
언제든지 메모리 부족과 같은 시스템 조건으로 인해 의도치 않게 종료될 수 있다.


5. 안드로이드 어플리케이션 설계 원칙
액티비티나 프래그먼트 같은 UI 컴포넌트에 많은 코드를 작성하기 쉽다.
Context, View, 데이터, 시스템 이벤트 등을 쉽게 참조 가능하기 때문이다.
UI 컴포넌트에 데이터를 저장하게 되면 예외 사항 대응이 힘들고, 거대해진 코드량 때문에 가독성도 떨어진다.

관심사의 분리가 필요
관심사 : 데이터에 영향을 미치는 정보의 집합
클래스간의 의존성을 느슨하게 하면서 모듈화하는 것으로 달성할 수 있다.


6. 권장하는 어플리케이션 설계
구글에서 권장하는 설계 방법
- 액티비티, 프래그먼트는 ViewModel만을 참조한다.
- ViewModel은 Repository라는 저장소를 참조하고, UI 컴포넌트가 화면을 구성하는데 필요한 데이터를 불러온다.
- 데이터는 LiveData라는 형태로 관리한다.
- 저장소는 두 가지 타입의 모델을 참조한다. 1) 네트워크 연결이 필요없는 내부 모델, 2) 네트워크가 필요한 원격 모델
- 데이터는 ViewModel에 관리하며 데이터의 변경이 감지되는 대로 UI 컴포넌트의 바인딩된 뷰에 나타낸다.
- ViewModel은 내부 데이터베이스 만을 항상 참조하고, 클라이언트의 데이터베이스와 서버의 데이터베이스가 요청으로 비동기적으로 동기화한다.

